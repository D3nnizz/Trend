<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Trend Dashboard — Light / Dark</title>

  <!-- ECharts & PapaParse -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.4.3/echarts.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

  <style>
    :root{
      /* Light theme */
      --bg-gradient: linear-gradient(135deg,#f5f7fa 0%,#c3cfe2 100%);
      --container-bg: rgba(255,255,255,0.95);
      --text-color: #2c3e50;
      --card-bg: #fff;
      --shadow: 0 10px 30px rgba(0,0,0,0.08);
      --border: #e0e6ed;
      --accent: #3498db;
      --accent-hover: #2980b9;
      --status-bg: rgba(46,204,113,0.08);
      --status-border: rgba(46,204,113,0.25);
      --status-color: #27ae60;
      --error-bg: rgba(231,76,60,0.08);
      --error-border: rgba(231,76,60,0.25);
      --error-color: #c0392b;
      --transition: 0.25s ease;
    }

    body.dark{
      /* Dark theme */
      --bg-gradient: linear-gradient(135deg,#12121a 0%,#243042 100%);
      --container-bg: rgba(28,32,44,0.92);
      --text-color: #ecf0f1;
      --card-bg: #1f2937;
      --shadow: 0 10px 30px rgba(0,0,0,0.6);
      --border: #3b4252;
      --accent: #9b59b6;
      --accent-hover: #8e44ad;
      --status-bg: rgba(46,204,113,0.12);
      --status-border: rgba(46,204,113,0.35);
      --status-color: #2ecc71;
      --error-bg: rgba(231,76,60,0.12);
      --error-border: rgba(231,76,60,0.35);
      --error-color: #e74c3c;
      --transition: 0.25s ease;
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      padding:20px;
      min-height:100vh;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      color:var(--text-color);
      background:var(--bg-gradient);
      transition: background var(--transition), color var(--transition);
    }

    .container{
      max-width:1400px;
      margin:0 auto;
      background:var(--container-bg);
      border-radius:14px;
      padding:28px;
      box-shadow:var(--shadow);
      transition: background var(--transition), box-shadow var(--transition);
      position:relative;
    }

    .header{ text-align:center; margin-bottom:20px; }
    .header h1{ margin:0; font-weight:300; font-size:2.25rem; letter-spacing:-0.5px }

    .theme-toggle{
      position:absolute;
      top:20px;
      right:24px;
      background:var(--accent);
      color:#fff;
      border:0;
      padding:8px 14px;
      border-radius:20px;
      cursor:pointer;
      font-size:14px;
      transition:background var(--transition), transform 0.12s;
    }
    .theme-toggle:hover{ background:var(--accent-hover); transform:translateY(-1px); }

    .controls{
      display:flex;
      justify-content:center;
      gap:18px;
      align-items:center;
      margin:18px 0 26px;
      flex-wrap:wrap;
    }

    .timeframe-selector select{
      padding:11px 18px;
      border-radius:10px;
      border:2px solid var(--border);
      background:var(--card-bg);
      color:var(--text-color);
      font-weight:600;
      cursor:pointer;
      appearance:none;
      transition:box-shadow var(--transition), border-color var(--transition);
    }
    .timeframe-selector select:hover{
      border-color:var(--accent);
      box-shadow:0 6px 18px rgba(0,0,0,0.06);
    }

    .status-indicator{
      display:flex;
      gap:10px;
      align-items:center;
      padding:8px 14px;
      border-radius:20px;
      background:var(--status-bg);
      border:1px solid var(--status-border);
      color:var(--status-color);
      font-weight:600;
      font-size:14px;
    }
    .status-dot{
      width:9px;
      height:9px;
      border-radius:50%;
      background:var(--status-color);
      animation:pulse 2s infinite;
    }
    @keyframes pulse{ 0%{opacity:1} 50%{opacity:.45} 100%{opacity:1} }

    .chart-container{
      height:520px;
      background:var(--card-bg);
      border-radius:10px;
      padding:18px;
      box-shadow:0 6px 18px rgba(0,0,0,0.04);
      transition:background var(--transition), box-shadow var(--transition);
    }

    .chart-info{
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(200px,1fr));
      gap:16px;
      margin-top:18px;
    }

    .info-card{
      background:var(--card-bg);
      padding:18px;
      border-radius:10px;
      box-shadow:var(--shadow);
      text-align:center;
      transition: transform 0.12s var(--transition), box-shadow var(--transition);
      border:1px solid transparent;
    }
    .info-card:hover{ transform:translateY(-6px); box-shadow:0 14px 36px rgba(0,0,0,0.12); border-color:var(--border) }

    .info-card h3{ margin:0 0 10px; font-size:13px; text-transform:uppercase; letter-spacing:1px; color:var(--text-color); opacity:.85 }
    .info-card .value{ font-size:20px; font-weight:700; color:var(--text-color) }

    .error-message{
      margin-top:18px;
      border-radius:8px;
      padding:12px 14px;
      background:var(--error-bg);
      border:1px solid var(--error-border);
      color:var(--error-color);
      text-align:center;
    }

    .loading{
      text-align:center;
      padding:30px;
      color:var(--text-color);
    }

    /* small responsive */
    @media (max-width:700px){
      .header h1{font-size:1.5rem}
      .chart-container{height:420px}
    }
  </style>
</head>
<body>
  <div class="container">
    <button id="themeToggle" class="theme-toggle">🌙 Dark Mode</button>

    <div class="header">
      <h1>Trend Dashboard</h1>
    </div>

    <div class="controls">
      <div class="timeframe-selector">
        <select id="timeframeSelect" aria-label="Select timeframe">
          <option value="trend_3m.csv">3 Minutes</option>
          <option value="trend_5m.csv">5 Minutes</option>
          <option value="trend_15m.csv">15 Minutes</option>
          <option value="trend_30m.csv">30 Minutes</option>
          <option value="trend_1h.csv">1 Hour</option>
          <option value="trend_4h.csv">4 Hours</option>
          <option value="trend_1d.csv">1 Day</option>
        </select>
      </div>

      <div class="status-indicator" title="Auto refresh interval">
        <div class="status-dot" aria-hidden="true"></div>
        <div>Auto-refresh: 1 min</div>
      </div>
    </div>

    <div class="chart-container">
      <div id="emaTrendChart" style="width: 100%; height: 100%;" aria-label="Trend chart"></div>
    </div>

    <div class="chart-info" role="region" aria-label="Chart summary">
      <div class="info-card">
        <h3>Latest Value</h3>
        <div id="latestValue" class="value">--</div>
      </div>

      <div class="info-card">
        <h3>Data Points</h3>
        <div id="dataPoints" class="value">--</div>
      </div>

      <div class="info-card">
        <h3>Last Updated</h3>
        <div id="lastUpdated" class="value">--</div>
      </div>

      <div class="info-card">
        <h3>Timeframe</h3>
        <div id="currentTimeframe" class="value">3 Minutes</div>
      </div>
    </div>

    <div id="errorMessage" aria-live="polite"></div>
    <div id="loadingMessage" class="loading" style="display:none">Loading data</div>
  </div>

  <script>
    // ---------- Config & state ----------
    let chart = null;
    let refreshInterval = null;
    const AUTO_REFRESH_MS = 60_000; // 1 minute
    const DEFAULT_CSV = 'trend_3m.csv';
    const TIME_LOCALE = 'nl-NL'; // Europe/Amsterdam locale for formatting

    const chartThemes = {
      light: {
        backgroundColor: '#ffffff',
        textColor: '#2c3e50',
        axisLineColor: '#e0e6ed',
        axisLabelColor: '#2c3e50',
        splitLineColor: '#f5f5f5',
        zeroLineColor: '#e74c3c',
        lineColor: '#3498db',
        areaColor: 'rgba(52,152,219,0.10)',
        tooltipBgColor: 'rgba(0,0,0,0.8)',
        tooltipTextColor: '#ffffff'
      },
      dark: {
        backgroundColor: '#1f2937',
        textColor: '#ecf0f1',
        axisLineColor: '#3b4252',
        axisLabelColor: '#ecf0f1',
        splitLineColor: '#374151',
        zeroLineColor: '#e74c3c',
        lineColor: '#9b59b6',
        areaColor: 'rgba(155,89,182,0.12)',
        tooltipBgColor: 'rgba(255,255,255,0.92)',
        tooltipTextColor: '#000000'
      }
    };

    // ---------- Chart initialization ----------
    function initChart(theme = 'light') {
      const chartDom = document.getElementById('emaTrendChart');
      
      // Dispose of existing chart if it exists
      if (chart) {
        chart.dispose();
        chart = null;
      }

      chart = echarts.init(chartDom);
      
      // Initialize with empty data to prevent errors
      const emptyOption = getChartOption(theme, [], []);
      chart.setOption(emptyOption, true);
    }

    function createGradientLineStyle(data) {
      // Ensure data is valid array with numeric values
      if (!Array.isArray(data) || data.length === 0) {
        return '#666666';
      }

      const values = data.filter(v => v !== null && v !== undefined && typeof v === 'number' && !isNaN(v));
      if (values.length === 0) return '#666666';
      
      const minVal = Math.min(...values);
      const maxVal = Math.max(...values);
      const range = maxVal - minVal;
      
      if (range === 0) {
        // All values are the same
        const value = values[0];
        if (value > 0.001) return '#22c55e'; // Green for above zero
        if (value < -0.001) return '#ef4444'; // Red for below zero
        return '#eab308'; // Yellow for around zero
      }

      // Create gradient with proper color mapping based on value position relative to zero
      const gradientStops = [];
      
      // Always create a 3-color gradient: Red (bottom) -> Yellow (middle/zero) -> Green (top)
      if (minVal < 0 && maxVal > 0) {
        // Data crosses zero - create full red->yellow->green gradient
        const zeroPosition = Math.abs(minVal) / range; // Position of zero in the range (0-1)
        
        gradientStops.push({ offset: 0, color: '#ef4444' });        // Red at bottom (most negative)
        gradientStops.push({ offset: zeroPosition, color: '#eab308' }); // Yellow at zero
        gradientStops.push({ offset: 1, color: '#22c55e' });        // Green at top (most positive)
      } else if (maxVal <= 0) {
        // All values are negative or zero - red to yellow gradient
        gradientStops.push({ offset: 0, color: '#ef4444' }); // Red for most negative
        gradientStops.push({ offset: 1, color: '#eab308' }); // Yellow approaching zero
      } else if (minVal >= 0) {
        // All values are positive or zero - yellow to green gradient  
        gradientStops.push({ offset: 0, color: '#eab308' }); // Yellow at zero
        gradientStops.push({ offset: 1, color: '#22c55e' }); // Green for most positive
      }

      return {
        type: 'linear',
        x: 0, y: 1, x2: 0, y2: 0,
        colorStops: gradientStops
      };
    }

    function createGradientAreaStyle(data) {
      function hexToRgba(hex, alpha) {
        const clean = (hex || '').replace('#', '');
        if (clean.length !== 6) return 'rgba(102, 102, 102, 0.15)';
        const r = parseInt(clean.substring(0, 2), 16);
        const g = parseInt(clean.substring(2, 4), 16);
        const b = parseInt(clean.substring(4, 6), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
      }

      const ls = createGradientLineStyle(data);
      
      if (typeof ls === 'object' && ls && ls.type === 'linear' && Array.isArray(ls.colorStops)) {
        // Create a more transparent version for area fill
        return {
          type: 'linear',
          x: 0, y: 1, x2: 0, y2: 0,  // Inverted: start from bottom to top
          colorStops: ls.colorStops.map(stop => ({
            offset: stop.offset,
            color: hexToRgba(stop.color, 0.15)
          }))
        };
      } else {
        // Single color, make it transparent
        const color = typeof ls === 'string' ? ls : '#666666';
        if (color === '#22c55e') return 'rgba(34, 197, 94, 0.15)';
        if (color === '#ef4444') return 'rgba(239, 68, 68, 0.15)';
        if (color === '#eab308') return 'rgba(234, 179, 8, 0.15)';
        return 'rgba(102, 102, 102, 0.15)';
      }
    }

    function getChartOption(theme, data = [], labels = []) {
      const t = chartThemes[theme];

      // Ensure both arrays are valid and the same length
      const safeData = Array.isArray(data) ? data : [];
      const safeLabels = Array.isArray(labels) ? labels : [];

      const minLen = Math.min(safeData.length, safeLabels.length);
      const finalData = safeData.slice(0, minLen);
      const finalLabels = safeLabels.slice(0, minLen);

      const lineStyle = createGradientLineStyle(finalData);
      const areaStyle = createGradientAreaStyle(finalData);

      return {
        backgroundColor: t.backgroundColor,
        title: {
          text: 'Trend',
          left: 'center',
          textStyle: {
            color: t.textColor,
            fontSize: 16,
            fontWeight: 'normal'
          }
        },
        tooltip: {
          trigger: 'axis',
          backgroundColor: t.tooltipBgColor,
          borderColor: t.tooltipBgColor,
          textStyle: {
            color: t.tooltipTextColor
          },
          formatter: function(params) {
            if (params && params.length > 0) {
              const param = params[0];
              const value = param.value;
              if (value !== null && value !== undefined && typeof value === 'number' && !isNaN(value)) {
                let colorIndicator = '';
                if (value > 0.001) colorIndicator = '🟢 ';
                else if (value < -0.001) colorIndicator = '🔴 ';
                else colorIndicator = '🟡 ';
                return `${colorIndicator}Time: ${param.axisValueLabel}<br/>Trend: ${Number(value).toFixed(6)}`;
              }
            }
            return 'No data available';
          }
        },
        legend: {
          data: ['Percentage'],
          top: 30,
          textStyle: {
            color: t.textColor
          }
        },
        grid: {
          left: '3%',
          right: '4%',
          bottom: '3%',
          top: '15%',
          containLabel: true
        },
        xAxis: {
          type: 'category',
          boundaryGap: false,
          data: finalLabels,
          name: 'Time',
          nameLocation: 'middle',
          nameGap: 25,
          nameTextStyle: {
            color: t.textColor,
            fontWeight: 'bold'
          },
          axisLine: { lineStyle: { color: t.axisLineColor } },
          axisLabel: { color: t.axisLabelColor, rotate: 45 },
          splitLine: {
            show: true,
            lineStyle: { color: t.splitLineColor, type: 'dashed' }
          }
        },
        yAxis: {
          type: 'value',
          name: 'Percantage',
          nameLocation: 'middle',
          nameGap: 45,
          nameTextStyle: { color: t.textColor, fontWeight: 'bold' },
          axisLine: { lineStyle: { color: t.axisLineColor } },
          axisLabel: {
            color: t.axisLabelColor,
            formatter: v => Number(v).toFixed(4)
          },
          splitLine: {
            show: true,
            lineStyle: { color: t.splitLineColor, type: 'dashed', width: 1 }
          }
        },
        series: [{
          name: 'Value',
          type: 'line',
          data: finalData,
          smooth: true,
          smoothMonotone: 'x',
          lineStyle: { color: lineStyle, width: 3 },
          itemStyle: {
            color: params => {
              const value = params.data;
              if (typeof value === 'number' && !isNaN(value)) {
                if (value > 0.001) return '#22c55e'; // Green
                if (value < -0.001) return '#ef4444'; // Red
                return '#eab308'; // Yellow
              }
              return '#666666'; // Gray for invalid
            }
          },
          areaStyle: { color: areaStyle },
          markLine: {
            symbol: 'none',
            label: { show: false },
            data: [{ yAxis: 0 }],
            lineStyle: { color: t.zeroLineColor, width: 2, type: 'solid' }
          },
          emphasis: { focus: 'series', lineStyle: { width: 4 } }
        }],
        animationDurationUpdate: 0
      };
    }

    function updateChartTheme(theme, isInit = false) {
      if (!chart) return;
      
      // Get current data safely
      const currentOption = chart.getOption();
      const currentData = currentOption?.series?.[0]?.data || [];
      const currentLabels = currentOption?.xAxis?.[0]?.data || [];
      
      const option = getChartOption(theme, currentData, currentLabels);
      chart.setOption(option, true);
      
      if (!isInit) {
        chart.resize();
      }
    }

    // ---------- Data loading (CSV) ----------
    async function loadData(filename) {
      const loadingEl = document.getElementById('loadingMessage');
      const errorEl = document.getElementById('errorMessage');
      loadingEl.style.display = 'block';
      errorEl.innerHTML = '';

      try {
        // Try multiple possible paths for the CSV files
        const possiblePaths = [
          `data/${filename}`,
          filename,
          `./${filename}`
        ];

        let resp = null;
        let lastError = null;

        for (const path of possiblePaths) {
          try {
            resp = await fetch(path, {cache: "no-store"});
            if (resp.ok) break;
            lastError = `HTTP ${resp.status} for ${path}`;
          } catch (e) {
            lastError = `Network error for ${path}: ${e.message}`;
          }
          resp = null;
        }

        if (!resp || !resp.ok) {
          // If no CSV files found, generate demo data
          console.warn(`Could not load ${filename}, generating demo data. Last error: ${lastError}`);
          const demoData = generateDemoData();
          updateChart(demoData);
          updateInfo(demoData, filename);
          
          document.getElementById('errorMessage').innerHTML = `<div class="error-message">
            ⚠️ CSV file "${filename}" not found. Showing demo data.<br>
            <small>Place your CSV files in a "data/" folder or the same directory as this HTML file.</small>
          </div>`;
          return;
        }

        const csvText = await resp.text();
        
        if (!csvText.trim()) {
          throw new Error('CSV file is empty');
        }

        const parseResult = Papa.parse(csvText, {
          header: true,
          dynamicTyping: true,
          skipEmptyLines: true,
          delimitersToGuess: [',',';','\t','|']
        });

        if (parseResult.errors && parseResult.errors.length) {
          // ignore harmless empty-row errors, but show if serious
          const serious = parseResult.errors.filter(e => e.code !== "TooFewFields");
          if (serious.length) {
            throw new Error('CSV parsing error: ' + serious.map(e => e.message).join('; '));
          }
        }

        if (!parseResult.data || !Array.isArray(parseResult.data)) {
          throw new Error('Invalid CSV structure - no data array found');
        }

        // filter rows that have timestamp and numeric trend_ema
        const rows = (parseResult.data && Array.isArray(parseResult.data) ? parseResult.data : []).filter(r => {
          return r && typeof r === 'object' && r.timestamp && r.trend_ema !== undefined && r.trend_ema !== null && r.trend_ema !== '' && !isNaN(Number(r.trend_ema));
        });

        if (!rows.length) {
          throw new Error('No valid data: ensure CSV includes `timestamp` and `trend_ema` columns with valid values.');
        }

        // sort ascending by timestamp
        rows.sort((a,b) => new Date(a.timestamp) - new Date(b.timestamp));

        // update chart & info
        updateChart(rows);
        updateInfo(rows, filename);

        // Clear any previous error messages on successful load
        errorEl.innerHTML = '';

      } catch (err) {
        document.getElementById('errorMessage').innerHTML = `<div class="error-message">Error loading ${filename}: ${err.message}</div>`;
        console.error('Data loading error:', err);
        
        // Generate demo data as fallback
        const demoData = generateDemoData();
        updateChart(demoData);
        updateInfo(demoData, filename);
      } finally {
        loadingEl.style.display = 'none';
      }
    }

    // ---------- Demo data generator ----------
    function generateDemoData() {
      const data = [];
      const startTime = new Date();
      startTime.setHours(startTime.getHours() - 2); // Start 2 hours ago
      
      for (let i = 0; i < 50; i++) {
        const time = new Date(startTime.getTime() + i * 3 * 60 * 1000); // 3-minute intervals
        // Generate EMA trend data that oscillates around zero with some noise
        const trend = Math.sin(i * 0.2) * 0.01 + (Math.random() - 0.5) * 0.005;
        
        data.push({
          timestamp: time.toISOString(),
          trend_ema: trend
        });
      }
      
      return data;
    }

    function updateChart(dataRows) {
      if (!chart || !Array.isArray(dataRows) || dataRows.length === 0) {
        return;
      }

      const labels = dataRows.map(r => {
        const d = new Date(r.timestamp);
        if (isNaN(d)) return r.timestamp; // fallback
        return d.toLocaleTimeString(TIME_LOCALE, { hour:'2-digit', minute:'2-digit', second:'2-digit' });
      });
      
      const values = dataRows.map(r => {
        const num = Number(r.trend_ema);
        return isNaN(num) ? null : num;  // keep nulls, don’t filter
      });


      if (values.length === 0) {
        console.warn('No valid numeric values found in data');
        return;
      }

      const currentTheme = document.body.classList.contains('dark') ? 'dark' : 'light';
      // const option = getChartOption(currentTheme, values, labels.slice(0, values.length));
      const option = getChartOption(currentTheme, values, labels);

      
      chart.setOption(option, true);
      
      // Center the y-axis around zero
      const maxAbs = Math.max(...values.map(v => Math.abs(v)));
      if (maxAbs > 0) {
        chart.setOption({
          yAxis: {
            min: -maxAbs * 1.1,
            max: maxAbs * 1.1
          }
        });
      }
    }

    function updateInfo(dataRows, filename) {
      if (!Array.isArray(dataRows) || dataRows.length === 0) {
        document.getElementById('latestValue').textContent = '--';
        document.getElementById('dataPoints').textContent = '0';
        document.getElementById('lastUpdated').textContent = new Date().toLocaleTimeString(TIME_LOCALE, { hour:'2-digit', minute:'2-digit', second:'2-digit' });
        return;
      }

      const latest = dataRows[dataRows.length - 1];
      const latestVal = latest ? Number(latest.trend_ema) : 0;
      const timeframeMap = {
        'trend_3m.csv': '3 Minutes',
        'trend_5m.csv': '5 Minutes',
        'trend_15m.csv': '15 Minutes',
        'trend_30m.csv': '30 Minutes',
        'trend_1h.csv': '1 Hour',
        'trend_4h.csv': '4 Hours',
        'trend_1d.csv': '1 Day'
      };

      document.getElementById('latestValue').textContent = (isNaN(latestVal) ? '--' : latestVal.toFixed(6));
      document.getElementById('dataPoints').textContent = dataRows.length;
      document.getElementById('lastUpdated').textContent = new Date().toLocaleTimeString(TIME_LOCALE, { hour:'2-digit', minute:'2-digit', second:'2-digit' });
      document.getElementById('currentTimeframe').textContent = timeframeMap[filename] || filename;
    }

    // ---------- Auto-refresh ----------
    function setupAutoRefresh() {
      if (refreshInterval) {
        clearInterval(refreshInterval);
      }
      refreshInterval = setInterval(() => {
        const selected = document.getElementById('timeframeSelect').value;
        loadData(selected);
      }, AUTO_REFRESH_MS);
    }

    // ---------- Theme handling ----------
    const themeToggle = document.getElementById('themeToggle');
    function applyTheme(theme) {
      document.body.classList.toggle('dark', theme === 'dark');
      // toggle button text
      themeToggle.textContent = theme === 'dark' ? '☀️ Light Mode' : '🌙 Dark Mode';
      // update Chart colors
      updateChartTheme(theme);
    }

    // ---------- Window resize handler ----------
    window.addEventListener('resize', function() {
      if (chart) {
        chart.resize();
      }
    });

    // ---------- Event listeners & initialization ----------
    document.getElementById('timeframeSelect').addEventListener('change', function() {
      const filename = this.value;
      localStorage.setItem('selectedTimeframe', filename);
      
      // Clear any existing error messages when manually changing timeframes
      document.getElementById('errorMessage').innerHTML = '';
      
      loadData(filename);
    });

    themeToggle.addEventListener('click', function() {
      const newTheme = document.body.classList.contains('dark') ? 'light' : 'dark';
      localStorage.setItem('theme', newTheme);
      applyTheme(newTheme);
    });

    window.addEventListener('beforeunload', function() {
      if (refreshInterval) clearInterval(refreshInterval);
      if (chart) chart.dispose();
    });

    // on load:
    window.addEventListener('load', function(){
      // restore saved timeframe & theme
      const savedTheme = localStorage.getItem('theme') || 'light';
      const savedTimeframe = localStorage.getItem('selectedTimeframe') || DEFAULT_CSV;

      // set timeframe select to saved value if present
      const tfSelect = document.getElementById('timeframeSelect');
      for (let i=0;i<tfSelect.options.length;i++){
        if (tfSelect.options[i].value === savedTimeframe) { tfSelect.selectedIndex = i; break; }
      }

      // init chart and theme
      initChart(savedTheme);
      applyTheme(savedTheme);

      // load data and start auto-refresh
      loadData(savedTimeframe, false).then(() => {
        setupAutoRefresh();
      }).catch(e => {
        console.error('Initial load error:', e);
        setupAutoRefresh(); // Start auto-refresh anyway
      });
    });
  </script>
</body>
</html>